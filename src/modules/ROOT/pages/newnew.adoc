= Data Models for Data Products
:page-toclevels: 1

// Team Semantiek (Netbeheer Nederland) authors and maintains data models for data products.

== What is a data model?

A *data model* is a model which describes the expected structure of data within a given context.

Typical applications of data models are the modeling of messages in data exchange and of schemas in database design. They enable processing data by machines, e.g. parsing, validating and transforming. Oftentimes data models also provide at least a rudimentary description of the meaning of its elements.

At any moment in time
Expressing a data model leads to a *data model version*. This is merely a logical expression

As the expression of the data model evolves,


leading to different *versions* of a data model. Two versions provide different descriptions of the application, possibly incompatibly different from a validation point of view. *Data model versions*

be seen as an expressions of the data model independent of (physical) implementation details. Two different versions of the same model provide different structural or semantic descriptions, but only in

NOTE: It is even valid if two versions are incompatible in the sense that a given data set may validate against one version and not the other, as long as the y

Each *data model version* is then embodied in one or more





a view on a system or information exchange, describing the structure, content, and semantics of data

.Alignment with FRBR and ADMS
****
To more precisely express the meaning of data models, data model versions and their representations, let's align these entities with FRBR:

|===
| Source | Mapping predicate | Target

.2+| Data model
| &#x2282;
| FRBR Work

| &#x2282;
| ADMS Asset

.2+| Data model version
| &#x2282;
| FRBR Expression

| &#x2282;
| ADMS Asset

.2+| Data model version representation
| &#x2282;
| FRBR Manifestation

| &#x2282;
| ADMS Asset distribution
|===

In FRBR terms:

* A *data model* _is realized by_
** a *data model version* which _is embodied by_
*** a *representation* footnote:[FRBR also distinguishes a _Item_ entity, but we omit this here.]

In ADMS terms:

* A *data model* _has version_
** a *data model version* which _has distribution_
*** a *distribution*

****

.Conceptual overview of a data model
// image::conceptual-model.png[width=203,height=389]
image::conceptual-model.png[]
// image::conceptual-model.png[alt=Conceptual overview of a data model,width=203,height=389,link=self,window=_new]
// xref::image$conceptual-model.png[Zoom in,window=_new]

data model::
  a semantic asset which represents the _solution_ of a data model for a data product
data model version::
  a semantic asset which realizes a data model
schema::
  a concrete view on a system or information exchange, describing the structure, content, and semantics of data

We borrow the definition of _schema_ from the ADMS Asset Type Controlled Vocabulary:

Since

== Representation

Data models are merely conceptual, abstract resources. Only data model _versions_ have representations.

Currently, the following representations are built for a version:

.Data model version representations
|===
| Kind | Technique | Media type | User type

| <<Schema>>
| LinkML
| YAML (`application/yaml`)
| machine

| <<Documentation site>>
| Antora/HTML
| HTML (`text/html`)
| human
|===

=== Schema

The _schema_ is a representation of a data model version intended for processing by machines. Typical use includes data parsing and validation.

The schema is written in the LinkML data modeling language, which is particularly suited for the modeling of data exchange in a decentral architecture.

=== Documentation site

The _documentation site_ is the representation suited for humans, which consists of:

* schema documentation generated from the <<Schema,schema>>
* additional documentation, usually written by humans

NOTE: The machine-processable schema representation can be obtained from the documentation site.

The documentation site is generated by the Antora framework, based on source files written primarily in AsciiDoc. These are battle-tested tools for writing technical documentation with great multi-project support.

=== Supporting artifacts

Data model versions may have additional artifacts included. Typically these are supporting resources such as example data, additional generated schemas (e.g. JSON Schema, SHACL, etc.) or additional documents.

The <<schema,schema>> and <<documentation site,documentation site>> should provide hyperlinks to these artifacts.

The following artifacts are included by default:

.Artifacts included by default
|===
| Kind | Representation technique | Media type | User type

.2+| Example data
| LinkML
| YAML
.2+a|
[unstyled]
* human
* machine

| JSON Schema
| JSON
|===

== Life cycle

The life cycle of a data model version is aptly described by the following state diagram:

.State diagram of a data model version
image::life-cycle.png[]
// [d2,svg]
// ----
// direction: right

// classes: {
//   state: {
//     width: 100
//     height: 100
//     shape: circle
//   }
// }

// *.class: state
// start.style {
//   double-border: true
//   border-radius: 50
// }
// end.style {
//   double-border: true
//   border-radius: 50
// }

// start -> draft
// draft -> accepted
// accepted -> released
// released -> retired
// retired -> end
// ----

The possible states are defined as follows:

// [horizontal,labelwidth=10]
[[state-draft]]draft:: under (active) development
[[state-accepted]]accepted:: at some point in time accepted to have its changes be an anticipated part of the upcoming release
[[state-released]]released:: stable and ready to be used by end-users
[[state-retired]]retired:: once released, but no longer supported

'''

=== See also

* xref::lifecycle-commitments.adoc[Commitments and guarantees], where the commitments and guarantees for each life cycle state are described.
* <<version_identifiers,Version identifiers>> to learn how those can be used to easily identify and locate versions depending on their life cycle state.

== Identification

Data models are assigned unique URIs for identification.

Data model versions, too, have URIs, which are based on the data model URI and a _version identifier_.

.URI templates
[cols="h,4"]
|===
| Data model
| `\https://modellen.netbeheernederland.nl/\{name}`

| Data model version
| `\https://modellen.netbeheernederland.nl/\{name}/\{version}`

|===

where:

[horizontal]
name:: the name of the data model footnote:[This inherits its name from the data product it models.]
version:: the <<version_identifier,version identifier>> of the data model version

=== Version identifier

A _version identifier_ is a string that disambiguates one version of a data model from another.

Version identifiers can be _dynamic_ (e.g. `latest` and `test`), or _static_ (e.g. `1.0` and `2.1.1-rc3`). We use dynamic identifiers to easily identify versions in a `draft` or `accepted` life cycle state, and static identifiers for releases.

[cols="2,4,1"]
|===
| Version identifier | Definition | Kind

| `draft`
| latestfootnote:[Technically, each subsequent draft version is another commit in `draft` branch of the Git repository. All of these commits are draft versions, but only the last can be identified and accessed through this dynamic version identifier.] <<state-draft,draft version>>
| dynamic


| `upcoming`
| latest <<state-accepted,accepted version>>
| dynamic

| `MAJOR.MINOR`
| specific <<state-released,released>> or <<state-retired,retired>> version
| static
|===

==== Major and minor versions

Releases have an identifier of the form `MAJOR.MINOR`, which are non-negative integers which encode compatibility information.

* `MAJOR` is incremented if existing data no longer validates against the model (_breaking changes occurred_).
* `MINOR` is incremented otherwise (_non-breaking changes occurred_).

// .Revision vs version
// ****
// The version identifiers `draft` and `upcoming` are _dynamic_, meaning they do not point to a fixed commit. Instead, they point to the latest commit of the `draft` and `main` branches respectively.


// Each Git commit on the `draft` branch is a <<state-draft,draft version>>, but the version indicator `draft` conveniently points dynamically to the latest commit on that branch. Therefore, in effect, it identifies the latest revision of the draft version.

// image::git-draft-branch.png[]

// Explain how you have Git-level revisions, which are 
// ****

NOTE: The identifier `draft` can only unambiguously identify the latest <<state-draft>> version if only one draft exists.

// Dereferencing the URI provides the representations of the model.


== Retrieval

#TODO#.

== Source files

#TODO#.

For every data model a dedicated Git repository exists where its source files are managed, and the source files of each model version are stored in commits.

=== Representation

|===
| Thing | Language | Syntax

| Schema
| LinkML
| YAML

| Documentation
| Antora
| AsciiDoc

| Example data
| LinkML
| YAML
|===

=== Version organization

// [horizontal]
`draft` branch:: contains commits of <<state-draft,draft versions>>
`main` branch:: contains commits of <<state-accepted,accepted versions>>
`X.Y` tag:: points to the specific commit of the <<state-released,released version>> identified by `X.Y` 
`retired` tag:: points to the specific commit of a <<state-retired,retired version>>

.Version of built vs source
[NOTE]
--
When referring to a version of the data model, we always refer to the built version, not the source version.

To refer specifically to the source files of a data model version, this should be explicitly qualified, e.g. "the source files of data model version 1.2".
--

// [mermaid,svg]
// ....
// ---
// config:
//   theme: neutral
//   class:
//     hideEmptyMembersBox: true
// ---
// classDiagram
// direction TB
//     class DataModel {
// 	    uri
//     }

//     class DataModelVersion {
// 	    uri
// 	    versionIdentifier
//     }

//     class VersionStatus {
// 	    DRAFT
// 	    ACCEPTED
// 	    RELEASED
// 	    RETIRED
//     }

//     class Representation {
//     }

//     class SourceFile {
//     }

//     class Document {
// 	    language
// 	    syntax
// 	    isMachineProcessable
//     }

// 	<<enumeration>> VersionStatus

//     Representation --|> Document
//     SourceFile --|> Document
//     DataModelVersion ..|> Representation : hasRepresentation
//     DataModelVersion --> VersionStatus : hasStatus
//     Representation o--> SourceFile : hasSource
//     DataModel <|.. DataModelVersion : versionOf
// ....

// image::conceptual-model.png[]

// image::conceptual-model.png[link=self,window=_new,width=406,height=778]